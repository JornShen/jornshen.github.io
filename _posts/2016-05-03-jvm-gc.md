---
layout: post
title: JVM GC
categories: JVM
description: JVM GC
keywords: JVM, GC
---

## 1. 判断对象“死”了吗？
垃圾收集器在进行对堆的回收前，首先要确定哪些对象还“活着”，哪些“死去”了

- 引用计数算法
地位：Java虚拟机并没有使用这种方式，因为它不能解决两个对象相互循环引用的问题。
<br>思路：给对象中添加一个引用计数器，当有地方引用它时，计数器+1，当引用失效时，计数器-1；当计数器为0时，对象就是不可能再被使用。

- 可达性分析算法
地位：主流商用JVM都是通过可达性分析算法判断对象是否存活。
<br>思路：通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots（坐标点）没有任何引用链相连时（不可达），则说明对象不可用。
<br>JAVA中，可作为GC Roots的对象如下：
  - 虚拟机栈中引用的对象
  - 方法区类静态属性引用的对象
  - 方法区中常量引用的对象
  - 本地方法栈中的JNI(Native方法)引用的对象

- 回光返照
即使可达性分析算法在判断为不可用，也不是非死不可。要真正宣告对象死亡，至少要经历两次标记过程：
  - 第一次：判断该不可达对象是否有必要执行finalize()方法
  - 第二次：在一基础上，加入FQueue队列，当轮到它，还没被改变finalize()状态，就真的挂了。

## 2. 垃圾收集算法
找到可以“死”了的对象后，如何回收呢？

- 标记-清除算法
思路：如其名字，算法分为“标记”和“清楚”两个阶段：首先标记（见上节）所有需要回收的对象，标记完后统一回收所有被标记的对象。
<br>不足：1. 效率问题（标记和清楚两个过程都是低效行为）；2.空间问题（产生大量不联系碎片，影响大对象）

- 复制算法（早死）
思路：它可将内存分为大小相等的两块a、b，当a用完后，将活着的复制到b，再清楚已使用过的内存空间，每次回收整个半区内存。`分配时就不用考虑碎片问题`。
<br>IBM研究表面，新生代对象中98%是“朝生晚死”（就是死的快，存活率低），所以不用按照1:1划分内存。而是`一个较小的Eden空间和2份较小的Survivor空间`。每次使用1份Eden和1份Survivor，当回收时，将这两份中还活着的对象一次性复制到另外一份Survivor空间，再清理掉刚刚的2份Eden，Survivor空间。

- 标记-整理算法（晚死）
当存活率较高时，要进行较多复制算法，效率降低。在所对象存活率很高情况下，在老年代一般不能选用这种算法。
<br>思路：过程同标记-清除算法，但是后续不是直接对可回收对象进行整理，而是让所有存活对象往一端移动，然后清除端边界外的内存。

- 分代收集算法
地位：现在商用虚拟机都是用分代收集算法，即根据对象存活周期，将内存划分为2块。
  - 新生代：每次垃圾收集时，大量死去（复制算法）。
  - 老生代：对象存活率高，无额外空间爱你进行分配担保（标记-整理算法）。

# 3. 垃圾收集器
收集算法只是内存回收的方法论，而垃圾收集器才是具体实现。

- Serial 收集器
单线程收集器，版本最早。在回收时，在用户不可见的情况下，把正常工作的所有线程停掉。

- ParNew 收集器
Serial 收集器的多线程版本。

- CMS 收集器
是一种以获取最短回收停顿时间为目的的收集器。基于“标记-清除算法”。

- G1 收集器（jdk1.7+）
  - 最前沿成果
  - 并行与并发
  - 分代收集
  - 空间整合
  - 可预测的停顿