---
layout: post
title: JVM运行时数据区域
categories: JVM
description: Java程序具体执行的过程,运行时数据区包括哪几部分？每部分职责
keywords: 运行时数据区, 编译器, 栈, 堆
---

## 1. Java程序具体执行的过程
- Java源码.java -（编译器compile）-> java.class --> classLoad(类加载器) --> Runtime Data Area（运行时数据区域）--> Execution Engine

- Java源代码文件(.java后缀)会被Java编译器编译为字节码文件(.class后缀)，然后由JVM中的类加载器加载各个类的字节码文件，加载完毕之后，交由JVM执行引擎执行。在整个程序执行过程中，JVM会用一段空间来存储程序执行期间需要用到的数据和相关信息，这段空间一般被称作为Runtime Data Area（运行时数据区），也就是我们常说的JVM内存。

## 2. 运行时数据区包括哪几部分？

- 线程隔离区（随线程生灭）
  程序计数器、虚拟机栈、本地方法栈

- 所有线程共享区
  堆、方法区

![此处输入图片的描述][1]

## 3. 每部分职责

- 程序计数器
<br>JVM中的程序计数器`是一块较小的内存空间`，并不像汇编语言中的程序计数器一样是物理概念上的CPU寄存器(保存下一条指令的所在存储单元的地址)，但是JVM中的程序计数器的功能跟汇编语言中的程序计数器的功能在逻辑上是等同的，也就是说是用来指示执行哪条指令的。`它是当前线程所执行的字节码的行号指示器，字节码解释器工作时通过改变该计数器的值来选择下一条需要执行的字节码指令，分支、跳转、循环等基础功能都要依赖它来实现。当线程在执行一个 Java 方法时，该计数器记录的是正在执行的虚拟机字节码指令的地址`。
<br>由于在JVM中，`多线程是通过线程轮流切换`来获得CPU执行时间的，因此，在任一具体时刻，`一个CPU的内核只会执行一条线程中的指令(单核CPU)`，因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己`独立的程序计数器`，并且不能互相被干扰，否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所`私有`的。
<br>在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的`指令的地址`；如果线程执行的是ative方法，则程序计数器中的值是`空`undefined。
<br>由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是(唯一一个在JVM)`不会发生内存溢出现象(OutOfMemory)`的。

- 虚拟机栈
Java栈是Java方法执行的内存模型。每个方法被执行的时候都会同时创建一个栈帧，栈它是用于支持续虚拟机进行方法调用和方法执行的数据结构。对于执行引擎来讲，`活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧`，这个栈帧所关联的方法称为当前方法，执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。在 Java 虚拟机规范中，对这个区域规定了两种异常情况：
  - 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。
  - 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。

  虚拟机栈中存放的是`一个个的栈帧`，每个栈帧对应一个被调用的方法，在栈帧中包括：`局部变量表(LocalVariables)、 操作数栈(OperandStack)、 指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)、方法返回地址(Return Address)`和一些额外的附加信息。
<br>当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。讲到这里，大家就应该会明白为什么在使用递归方法的时候容易导致栈内存溢出的现象了以及为什么栈区的空间不用程序员去管理了（当然在Java中，程序员基本不用关系到内存分配和释放的事情，因为Java有自己的垃圾回收机制），这部分空间的分配和释放都是由系统自动实施的。对于所有的程序设计语言来说，栈这部分空间对程序员来说是不透明的。
1. 局部变量表
局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，其中存放的数据的类型是编译期可知的各种`基本数据类型、对象引用（reference）和 returnAddress 类型（它指向了一条字节码指令的地址）`。局部变量表所需的内存空间在编译期间完成分配，即在 Java 程序被编译成 Class 文件时，就确定了所需分配的最大局部变量表的容量。当进入一个方法时，这个方法需要在栈中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。
<br>局部变量表的容量以`变量槽（Slot）为最小单位`。在虚拟机规范中并没有明确指明一个 Slot 应占用的内存空间大小（允许其随着处理器、操作系统或虚拟机的不同而发生变化），一个 Slot 可以存放一个32位以内的数据类型：boolean、byte、char、short、int、float、reference 和 returnAddresss。reference 是对象的引用类型，returnAddress 是为字节指令服务的，它执行了一条字节码指令的地址。对于 64 位的数据类型（long和double），虚拟机会以高位在前的方式为其分配两个连续的 Slot 空间。
<br>虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从 0 开始到局部变量表最大的 Slot 数量，`对于 32 位数据类型的变量，索引 n 代表第 n 个 Slot，对于 64 位的，索引 n 代表第 n 和第 n+1 两个 Slot`。
<br>在方法执行时，`虚拟机是使用局部变量表来完成参数值到参数变量列表的传递过程的`，如果是实例方法（非static），则局部变量表中的`第 0 位索引的 Slot 默认是用于传递方法所属对象实例的引用`，在方法中可以通过关键字“this”来访问这个隐含的参数。其余参数则按照参数表的顺序来排列，占用从1开始的局部变量 Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的 Slot。
<br>`局部变量表中的 Slot 是可重用的，方法体中定义的变量，作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超过了某个变量的作用域，那么这个变量对应的 Slot 就可以交给其他变量使用`。这样的设计不仅仅是为了节省空间，在某些情况下 Slot 的复用会直接影响到系统的而垃圾收集行为。

2. 操作数栈
操作数栈，想必学过数据结构中的栈的朋友想必对表达式求值问题不会陌生，栈最典型的一个应用就是用来对表达式求值。想想一个线程执行方法的过程中，实际上就是不断执行语句的过程，而归根到底就是进行计算的过程。因此可以这么说，`程序中的所有计算过程都是在借助于操作数栈来完成`的。
<br>操作数栈又常被称为操作栈，操作数栈的最大深度也是在编译的时候就确定了。32 位数据类型所占的栈容量为 1,64 位数据类型所占的栈容量为 2。当一个方法开始执行时，它的操作栈是空的，在方法的执行过程中，会有各种字节码指令（比如：加操作、赋值元算等）向操作栈中写入和提取内容，也就是入栈和出栈操作。
<br>Java 虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。因此我们也称 Java 虚拟机是基于栈的，这点不同于 Android 虚拟机，Android 虚拟机是基于寄存器的。
<br>基于栈的指令集最主要的优点是可移植性强，主要的缺点是执行速度相对会慢些；而由于寄存器由硬件直接提供，所以基于寄存器指令集最主要的优点是执行速度快，主要的缺点是可移植性差。

3. 动态连接
每个栈帧都包含一个指向运行时常量池（在方法区中，后面介绍）中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class 文件的常量池中存在有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用，一部分会在类加载阶段或第一次使用的时候转化为直接引用（如 final、static 域等），称为静态解析，另一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接。

4. 方法返回地址
当一个方法被执行后，有两种方式退出该方法：执行引擎遇到了任意一个方法返回的字节码指令、遇到了异常，并且该异常没有在方法体内得到处理。无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行。
<br>方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的 PC 计数器的值就可以作为返回地址，栈帧中很可能保存了这个计数器值，而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。
<br>方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，如果有返回值，则把它压入调用者栈帧的操作数栈中，调整 PC 计数器的值以指向方法调用指令后面的一条指令。

- 本地方法栈
本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而`本地方法栈则是为执行本地方法（Native Method）服务的`。在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。

- 堆
堆是用来存储`对象本身的以及数组`（当然，数组引用是存放在Java栈中的,成员变量存放在堆中）。只不过和C语言中的不同，在Java中，程序员基本不用去关心空间释放的问题，Java的垃圾回收机制会自动进行处理。因此这部分空间也是Java垃圾收集器管理的主要区域。另外，堆是被所有线程共享的，在JVM中只有一个堆。
<br>根据 Java 虚拟机规范的规定，Java 堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存可分配时，并且堆也无法扩展时，将会抛出 OutOfMemoryError 异常。

- 方法区
方法区与堆一样，是被线程共享的区域。在方法区中，`存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码`等。
<br>在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池（java中的常量池技术，是`为了方便快捷地创建某些对象而出现的`，当需要一个对象时，就可以从池中取一个出来（如果池中没有则创建一个），则在需要重复重复创建相等变量时节省了很多时间。常量池其实也就是一个内存空间），用来存储编译期间生成的字面量和符号引用。
  - 字面量
  1. 文本字符串
  2. 声明为final的常量和值
  - 符号引用
  1. 类和接口的全限定名
  2. 字段的名称和描述符
  3. 方法的名称和描述符

  主要包括：
  1. 常量池中对象和堆中的对象
  2. 八种基本类型的包装类和对象池
  3. String也实现了常量池技术

  它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如`String的intern方法`。
<br>在JVM规范中，没有强制要求方法区必须实现垃圾回收。很多人习惯将方法区称为“永久代”，是因为HotSpot虚拟机以永久代来实现方法区，从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，从而不需要专门为这部分设计垃圾回收机制。不过自从JDK7之后，Hotspot虚拟机便将运行时常量池从永久代移除了。
<br>根据 Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。

------------------------------------

引用：[深入理解Java虚拟机][2]，[极客学院][3]

  [1]: http://o6ubi7qg2.bkt.clouddn.com/jdkrunmemory.png
  [2]: https://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00D2ID4PK
  [3]: http://wiki.jikexueyuan.com/project/java-vm/storage.html
