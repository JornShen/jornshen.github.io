---
layout: post
title: 1NF 2NF 3NF
categories: SQL
description: 1NF 2NF 3NF
keywords: 1NF 2NF 3NF
---

## 第1范式

- 强调的是列的原子性，无重复的列 。
用户：user_table

|用户ID(key)|姓名|电话号码|
|:--:|:--:|:--:|
|1|admin|136x...x|

电话需要分为手机电话、家里座机电话，这里不符合原子性，需要改为：

|用户ID(key)|姓名|手机号码|座机号码|
|:--:|:--:|:--:|:--:|
|1|admin|136x...x|025x...x|

## 第2范式

- 属性完全依赖于主键
 满足1NF。每个非主属性都完全依赖于主键，即如果主键是复合主键，则每一个非主键属性都完全依赖于主键的每一项，而不是仅仅依赖于复合主键的一部分。
<br>首先我们考虑，把所有这些信息放到一个表中

|学号(key1)|学生姓名|年龄|性别|课程名称(key2)|课程学分|系别|学科成绩|系办地址|系办电话|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|23020151153XXX|mh|1|男|操作系统|2|CS|100|xmu|025x...x|

下面存在如下的依赖关系。
<br>（学号）→ （姓名，年龄，性别，系别，系办地址、系办电话）
（课程名称） → （学分）
（学号，课程）→ （学科成绩）

- 问题分析
不满足第二范式的要求，会产生如下问题：
  - 数据冗余：同一门课程由n个学生选修，"学分"就重复n-1次；同一个学生选修了m门课程，姓名和年龄就重复了m-1次。
  - 更新异常：
  1. 若调整了某门课程的学分，数据表中所有行的"学分"值都要更新，否则会出现同一门课程学分不同的情况。
  2. 假设要开设一门新的课程，暂时还没有人选修。这样，由于还没有"学号"关键字，课程名称和学分也无法记录入数据库。
  - 删除异常：假设一批学生已经完成课程的选修，这些选修记录就应该从数据库表中删除。但是，与此同时，课程名称和学分信息也被删除了。很显然，这也会导致插入异常。

- 解决方案
把选课关系表SelectCourse改为如下三个表：
学生：Student（满足2NF，但是不满足3NF）

|学号(key)|姓名|年龄|性别|系别|系办地址|系办电话|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|&emsp;|&emsp;|&emsp;|&emsp;|&emsp;|&emsp;|&emsp;|

&emsp;&ensp;课程：Course

|课程名称(key)|学分|
|:--:|:--:|
|&emsp;|&emsp;|

&emsp;&ensp;选课关系：SelectCourse

|学号(key1)|课程名称(key2)|成绩|
|:--:|:--:|:--:|
|&emsp;|&emsp;|&emsp;|

## 第3范式

- 属性不依赖于其它非主属性[消除传递依赖]
首先是满足 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。
<br>接着看上面的学生表Student

|学号(key)|姓名|年龄|性别|系别|系办地址|系办电话|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|&emsp;|&emsp;|&emsp;|&emsp;|&emsp;|&emsp;|&emsp;|

&emsp;&ensp;关键字为单一关键字"学号"，因为存在如下决定关系：
&emsp;&ensp;（学号）→（姓名，年龄，性别，系别，系办地址，系办电话）
&emsp;&ensp;但是还存在下面的决定关系：
&emsp;&ensp;（学号）→ （所在学院）→ 学院地点,学院电话）

&emsp;&ensp;即存在非关键字段"学院地点"、"学院电话"对关键字段"学号"的传递函数依赖。
&emsp;&ensp;它也会存在数据冗余、更新异常、插入异常和删除异常的情况。
&emsp;&ensp;根据第三范式把学生关系表分为如下两个表就可以滿足第三范式了：
&emsp;&ensp;学生：Student（满足2NF，但是不满足3NF）

|学号(key)| 姓名| 年龄| 性别|系别|
|:--:|:--:|:--:|:--:|:--:|
|&emsp;|&emsp;|&emsp;|&emsp;|&emsp;|

&emsp;&ensp;系别：

|系别(key)|系办地址|系办电话|
|:--:|:--:|:--:|
|&emsp;|&emsp;|&emsp;|

## 总结

&emsp;&ensp;第二范式（2NF）和第三范式（3NF）的概念很容易混淆，区分它们的关键点在于（主键已确认的基础上）：
&emsp;&ensp;2NF：非主键列是否完全依赖于主键，还是依赖于主键的一部分，单个主键肯定满足二范式
&emsp;&ensp;3NF：非主键列是直接依赖于主键，还是直接依赖于非主键列