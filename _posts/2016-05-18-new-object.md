---
layout: post
title: 新建Java对象在堆上了发生什么
categories: Java
description: 新建Java对象在堆上了发生什么
keywords: JVM, 内存申请, 内存分配
---

## 1. 创建对象的方法有哪些
最常用的就是关键字new，当发生new操作时，JVM为你做了什么？
<br>我们先把这个问题放下，对于jvm初始化加载专门处理，这里先说除了new、XXX.class、xxx.getClass()之外，就是通过java.lang.Class.forName进行动态状态后，获取一个新的实例，当然方法有重载，也通过通过ClassLoader进行动态状态，什么是动态装载？为什么有了new还要有动态装载？而jvm初始化做了什么？
<br>动态装载和new的区别是什么？这也是我们下面要讨论的问题，也是PermSize中内容的一大块部分。

## 2. JVM初始化需要做什么
JVM遇到一条new指令时，`首先将去检查这个指令的参数是否能在常量池中定位一个类的符号引用，并且检查这个符号引用代表类是否一杯加载、解析、初始化过`。如果没有，那必须先执行相应的[类加载][1]过程。JVM在向OS请求了一块地址列表后，然后就需要初始化了，初始化要做什么呢？
<br>`JVM启动相当于一个进程`，当然它可以再启动子进程，这里我们只考虑单个进程，进程启动必然需要初始化一些内容。C语言或者C++它会将相应的全局变量以及代码段等内容在内存中进行编译为相应的指令集。而JVM做了什么呢？
<br>JVM它也需要做一些操作，`首先每一个进程都必须最少一个引导进程，也就是我们说的main`，通过引导进程所关联，以及关联的`关联（也就是import）`，JVM会将这些关联关系的内容形成一个大的JVM网状结构用于关系于class之间并保证每一个class有一份自己的私有池。
<br>这些私有池放在哪里，它们就是放在PermSize，也就是很多中文翻译中的永久代，每一个Class都有自己独立的私有池去管理自身的结构，对一个java程序源文件，编写的是对于程序的描述信息，生成class也就是描述信息的byte格式（在这个过程中会自动完成一些简单逻辑合并工作），byte格式是字节码格式，也就是按照每8个bit位组成的计算机基本格式，只要字符集统一，则为每一个操作系统所认知的格式，JVM需要做的是将这些统一认知的格式信息翻译为对应操作系统的指令或硬件指令，所以JVM真正的意义就是为每一个操作系统编写了一个统一的JRE，即：java运行时环境，而编译环境是所有系统都可以使用的；
<br>初始化将class的定义加载到内存中会进行相应的转换和压缩，总之会形成原有对类型描述和执行顺序，而不会出现混乱。但并不是对应的操作系统指令（对应的操作系统指令是运行时知道的），如描述类型、作用域、访问权限等等内容。这部分空间大小决定于class的多少，也就是你的工程的大小，PermSize还包含了其他的内容，并且只是在一般情况下不会发生GC，但是有些时候还是会发生GC的，在后面继续说明。
<br>这个加载完成后，他们在池中自然有自己的内存首地址，要寻找他必然要有对应列表，列表的基础肯定是属于符号向量了，也就是基于名称的一个符号向量，那么当发生new时，它会在符号向量中寻找对应的class，找到后将符号地址转换为对应的class地址，并且这个内容只会被转载一次，`以后可以直接被利用`，从中找到了class的定义，在堆中分配内存时将其定义部分的某些组织单元放置与对象的头部，这些代码段对于对象来说是彼此独立。
<br>注意，这里还没有谈到申请对象以及动态装载，动态装载的class一般是不会JVM初始化的时候转入Perm的，而是运行时动态装载进去的，就像JDBC驱动一样，大家几乎都用动态装载来实现动态加载不同数据库连接的目的；也就是我们上一节提出的问题，动态装载做什么？它负责的是运行时装载一些类的定义，而不是初始化，当然，当你通过全名去加载的时候，他们会从符号向量中寻找这个类是否已经加载，如果已经加载则直接使用，否则从相应的包中获取这个class定义，然后装载起来，装载的单位也是以class为单位，并不是以jar包为单位，这里请大家不要滥用动态加载，`一则造成Perm的不稳定，二则是它的效率肯定没有new高`（因为它需要先去通过符号向量寻找是否存在，不存在再加载，然后再通过newInstance实例化一个或多个实例）当然在某些特殊的时候，利用它可以为你的程序带来极高的灵活性，如Web框架。

## 3. 内存申请时的指针与实例（条带化）
在JVM的初衷中，它希望新申请的内存是连续的，虽然堆的定义是让内存是随机分配的，但是对于整个JVM来说，它希望分配的内存是较为连续的，也就是按照较为条带化的方式进行分配。
<br>好处有2个：
1. 一个是这样非常的简单，经过精简后的情况目前一个new翻译为机器码只需要10条左右的指令码，近乎与C语言，所以在高版本的jdk中，new的开销不再是java虚拟机慢的一个原因，大家也没有必要去尽量减少new，但是也不要滥用；
2. 当内存较为连续后，内存在分配上就没有类似的大量碎片的问题，造成运行一段时间后，大量碎片，当需要申请一个大内存的时候，需要寻找非常多的地方才能将其逻辑上组成，而导致分配空间上不必要的浪费。

  <br>这里顺便提及一下：在较早期的jdk中，jvm并不是由一个指针直接指向分配堆中的首地址，而是先有一个handle空间，这个空间存放了开始说的一些对象的定义和结构信息，也就是找到该位置，然后由该位置转换到对应的对象上，但是那个时候的对象头部信息就没有现在的那么全，也就是以前是将一部分handle内容放置在独立的空间上，现在的jdk已经没有那样的了。

## 4. 内存分配后放在哪里，如何移动
终于回到上面的话题，内存分配后，在堆中的什么位置？就是我们上面说的heapSize中的Young区域的Eden区域中，也就是new的对象绝大部分会放在这里（排除一种非常大的对象的特殊情况），在java设计的看来有一个特别有意思的地方，就是它在新生成的对象中它认为你绝大部分对象都是应该需要被销毁掉的，就像在做java WEB应用上一样，一个列表请求过来，可能请求的内容有2K的内容，请求完成后，这个内容一般说来自然就不需要了，也就是在他原始的考虑下它没有考虑你自己在应用级别去做page cache的操作；好，那么当内存不够的时候，这里指被commited的空间不够的情况下，此时java就会做一个动作，就是会对Young空间进行回收，由于新生成的对象，java认为这块空间不会很大，而且绝大部分应该是被干掉的内容，所以很多时候java会采用单线程的`复制算法`（当然你也可以设置为多线程），这里总之先理解找到了活着的对象，将其拷贝到其中一个survivor区域中，当下一次做操作时，就会将Eden中活着的以及前一个surivor活着的一起拷贝到另一个survivor中，这就是为什么要设置两个survivor区域，而拷贝后，Eden区域为空、另一个survivor也为空，可以完全直接整体清除掉，所以非常快速，而拷贝的目标也会被连续化，新生成的对象又从Eden的初始位置开始分配空间。
<br>当对象每次（活着）被拷贝到一个survivor时，Java虚拟机就会记录下来对象被移动的次数，当次数达到一定的程度，也就是官方文档所说的足够老的情况，这块内存就认为它不太容易被注销掉，此时就会被移动到第二个区域Tenured区域（老年代），这个次数也可以由自己来控制。
<br>另外在一般默认的情况下当回收后的内存仍然占用实际目前commited内存的70%以上，那么此时虚拟机将会开始扩展这些内存，而当回收后的内存小于40%后，虚拟机将会降低这部分内存，但是其他线程仍然不能使用（当然这个参数也是可配置的，在文章最后有说明），这样收缩和扩展必然导致一些问题，但是java的初衷是想让你再没有使用这块地址表的时候，回收内存的大小会小一些，因为young区域的一般是使用单线程的回收方式，这个时间段是会被暂停的，所以它认为内存使用较少的时候回收就内存的速度应该加快；但是，和实际相反的是，我们正好需要的是内存使用较大的时候，才希望加快回收的速度，内存使用小的时候，回收都是无所谓的；所以我们在很多时候建议将-Xms和-Xmx设置成一样的大小，不用这么来回倒腾。
<br>在说明下，以下三种情况对象会被晋升到old区域：
1. 在eden和survivor中可以来回被minor gc多次，这个次数超过了-XX:MaxTenuringThreshold
2. 在发生minor gc时，发现to survivor无法放下这些对象，就会进入old。
3. 在新申请对象，大于eden区域的一半大小时直接进入old，也可以专门设置参数-XX:PretenureSizeThreshold这个参数指定当超过这个值就直接进入old。

  <br>当上面的对象被移动到了Tenured区域，这个区域一般非常大，占用了HeapSize的绝大部分空间，此时若它发生一次内存回收，就不能像刚才那样来回拷贝了，那样代价太大，而且这个区域可以说是经得起考验的对象才会被移动过来，在概率上是不容易被销毁掉的对象才会被移动过来；那么，我们很此时想到的就是反过来计算，也就是找到需要销毁的对象，将其销毁，关于算法也是下面第三章要说的内容，总之对象会在这里存放着。
<br>为什么java不论在Young中的区域会来回倒腾，而在Tenured区域也会不断去做压缩，就是我们前面说的，它希望内存相对较为连续而做的；java在Yong的区域，它认为可以剩下的内容不会很多，所以拷贝的代价并不大，所以它认为来回拷贝是一种合适的方法，而Tenured区域它采用了清除后，一定次数后进行压缩的方式，当然这个次数你可以自己去设置，在文章的最后是有参数的；而它没有采用类似操作系统一样的按照板块大小等一系列算法来完成，这也是我比较纳闷的事情，不过总体说来这种算法还是可行的；希望在划分区域一些策略上能有更大的灵活性，这样可以在更多的应用中发挥得更加灵活，这样就更好了；比较困惑的就是这样的架构自己如果做频繁度不高不低的page cache，性能不好估量，也许比不做cache更低，这个要根据具体情况而定了。

## 5. Perm一般还会存放什么内容
Perm除了存放上面的Class定义外，还一般会存放的内容有静态代码段、final、static类型的类变量、String常量以及String被intern后的内容。
<br>如何应对好常量池，以及常量池是否会被GC，也是我们所需要说明的内容；关于Perm永久代中存放的内容，应当如何配置以至于它可以去回收，在文章的最后有相应的说明，请自行查阅；不过对于Perm的大小，一般还是不建议去做GC的，也就是合理的去使用Perm，在程序运行中占用Perm最多的就是String常量，尤其是如果大量使用intern的时候，就会造成大量Perm膨胀，也是最后一部分需要说明的内容，不过intern也并非一无是处，因为你可以这样说：如果它没有用处的话，java没有必要再把String的常量放在单独的一个地方，它有很多好处，只要在适当的时候利用好常量池这个区域在必要的时候可以提高性能。

------------------------------------------

引用：[ImportNew-认识JVM（上）][2]，[深入理解Java虚拟机][3]

  [1]: http://monkeyhorse.cn/posts/15
  [2]: http://www.importnew.com/18242.html
  [3]: https://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00D2ID4PK